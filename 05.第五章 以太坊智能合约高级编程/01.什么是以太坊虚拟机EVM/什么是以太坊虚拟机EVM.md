# 什么是以太坊虚拟机 EVM

### 5.1.1 概述

在前面章节已经学习过以太坊虚拟机，本章节对前文的该知识点进行一些补充。EVM 是以太网上智能合约的运行环境，是以太坊协议的一部分，它用来处理智能合约的部署和执行。这不仅仅是个沙盒，更确实的是一个完全独立的环境，也就是说代码运行在 EVM 里是没有网络，文件系统或是其他进程的，智能合约甚至被限制访问其他的智能合约。

事实上，除了在 EOA 之间的简单转账交易以外，其他所有涉及状态更新的操作都是通过 EVM 来计算的。从高层抽象的角度，运行在以太坊区块链上的 EVM 可以被想象成一个包含了数百万可执行对象的全球化的去中心化计算机，这些可执行对象都拥有它们各自的永久数据存储。

EVM 是一个“准”图灵完备的状态机，因为在其中进行的任意智能合约的执行都必须限定在一个由可用的 gas 总量所限制的、有限的计算步骤数量之内。这样，停机故障（指所有程序执行都被迫停止）就被“解决了”，并且避免了程序可能会（意外地或者恶意地）永远执行下去，从而使以太坊平台进入完全停止的状态的问题。

EVM 有一个基于栈的架构，在一个栈中保存了所有内存数值。EVM 的数据处理单位被定义为 256 位的“字”（这主要是为了方便处理哈希运算和椭圆曲线运算操作），并且它还具有以下数据组件：

- 一个不可变的程序代码存储区 ROM，加载了要执行的智能合约字节码。
- 一个内容可变的内存，它被严格地初始化为全 0 数值。
- 一个永久的存储，它是作为以太坊状态的一部分存在的，也会被初始化为全 0。

### 5.1.2 账号

在以太坊中有两种账号共享地址空间：外部账号和合约账号。外部账号是由公钥和私钥控制的（如人），合约账号是由账号存储的代码所控制。 外部账号的地址是由公钥决定的，而合约地址是在智能合约被创建的时候决定的（这个地址由创建者的地址和发送方发送过来的交易数字衍生而来，这个数字通常被叫做“nonce”）不管是否账号存有代码（合约账号存储了代码，而外部账号没有），对于 EVM 来说这两种账号是相等的。

每一个账号都有持久化存储一个 key 和 value 长度都为 256 位字的键值对，被称为“storage”，而且，在以太坊中，每个账号都有一个余额（确切的是用“Wei”来作为基本单位），该余额可以被发送方发送过来带有以太币的交易所更改。

### 5.1.3 交易

交易是一个账号和另外一个账号之间的信息交换。它包含了二进制数据（消费数据）和以太数据。如果目标账号包含了代码，这个代码一旦被执行，那么它的消费数据就会作为一个输入数据。如果目标账号是一个 0 账号（地址为 0 的账号），交易会生成一个新的合约。这个合约的地址不为 0，但是是来源于发送方，之后这个账号的交易数据会被发送。这个合约消费会被编译为 EVM 的二进制代码，并执行。这次的执行会被作为这个合约的代码持久化。这就是说：为了创建一个合约，操作者不需要发送真正的代码到这个合约上，事实上是代码的返回作为合约代码。

### 5.1.4 Gas

在前面章节本书已经提到过 Gas，以太坊上的每进行一笔交易都会被收取一定数量的 Gas.这是为了限制交易的数量，同时对每一笔交易的进行支付额外费用。当 EVM 执行一个交易，交易发起方就会根据定义的规则消耗对应的 Gas。 交易的创造者定义了的 Gas 价格。所以交易发起方每次需要支付 gas_price * gas 。如果有 gas 在执行后有剩余，会以同样的方法返回给交易发起方。如果 gas 在任何时候消耗完，out-of-gas 异常会被抛出，那当前的这边交易所执行的后的状态全部会被回滚到初始状态。

### 5.1.5 存储，主存和栈

每个账号都有持久化的内存空间叫做存储. 存储是一个 key 和 value 长度都为 256 位的 key-value 键值对。从一个合约里列举存储是不大可能的。读取存储里的内容是需要一定的代价的，修改 storage 里的内容代价则会更大。一个合约只能读取或是修改自己的存储内容。第二内存区域叫做主存。系统会为每个消息的调用分配一个新的，被清空的主存空间。主存是线性并且以字节粒度寻址。读的粒度为 32 字节（256 位），写可以是 1 个字节（8 位）或是 32 个字节（256 字节）。当访问一个字（256 位）内存时，主存会按照字的大小来扩展。主存扩展时候，消耗 Gas 也必须要支付,主存的开销会随着其增长而增大（指数增长）。EVM 不是一个基于寄存器，而是基于栈的。所以所有的计算都是在栈中执行。最大的 size 为 1024 个元素，每个元素为 256 位的字。栈的访问限于顶端，按照如下方式：允许拷贝最上面的 16 个元素中的一个到栈顶或是栈顶和它下面的 16 个元素中的一个进行交换。所有其他操作会从栈中取出两个（也有可能是 1 个或多个，这取决于操作）元素，把操作结果在放回栈中。当然也有可能把栈中元素放入到存储或是主存中，但是不可能在没有移除上层元素的时候，随意访问下层元素。

### 5.1.6 指令集

为了避免错误的实现而导致的一致性问题，EVM 的指令集保留最小集合。所有的指令操作都是基于 256 位的字。包含有常用的算术，位操作，逻辑操作和比较操作。条件跳转或是非条件跳转都是允许的。而且合约可以访问当前区块的相关属性比如编号和时间戳。

### 5.1.7 消息调用

合约可以通过消息调用来实现调用其他合约或是发送以太币到非合约账号。消息调用和交易类似，他们都有一个源，一个目标，数据负载，以太币，gas 和返回的数据。事实上，每个交易都包含有一个顶层消息调用，这个顶层消息可以依次创建更多的消息调用。一个合约可以定义内部消息调用需要消耗多少 gas,多少 gas 需要被保留。如果在内部消息调用中出现 out-of-gas 异常，合约会被通知，会在栈里用一个错误值来标记。这种情况只是这次调用的 gas 被消耗完。在 Solidity，这种情况下调用合约会引起一个人为异常，这种异常会抛出栈的信息。 上面提到，调用合约会被分配到一个新的，并且是清空的主存，并能访问调用的负载。调用负载时被称为 calldata 的一个独立区域。调用结束后，返回一个存储在调用主存空间里的数据。这个存储空间是被调用者预先分配好的。调用限制的深度为 1024.对于更加复杂的操作，本书推荐使用循环而不是递归。

### 5.1.8 代理调用/代码调用和库

存在一种特殊的消息调用，叫做代理调用。除了目标地址的代码在调用方的上下文中被执行，而且 msg.sender 和 msg.value 不会改变他们的值，其他都和消息调用一样。这就意味着合约可以在运行时动态的加载其他地址的代码。存储，当前地址，余额都和调用合约有关系。只有代码是从被调用方中获取。这就使得操作者可以在 Solidity 中使用库。比如为了实现复杂的数据结构，可重用的代码可以应用于合约存储中。

### 5.1.9 日志

操作者可以把数据存储在一个特殊索引的数据结构中。这个结构映射到区块层面的各个地方。为了实现这个事件，在 Solidity 把这个特性称为日志。合约在被创建出来后是不可以访问日志数据的。但是他们可以从区块链外面有效的访问这些数据，因为日志的部分数据是存储在 bloom filters 上。操作者可以用有效并且安全加密的方式来查询这些数据，即使不用下载整个区块链数据（轻客户端）也能找到这些日志。

### 5.1.10 创建合约

合约可以通过特殊的指令来创建其他合约。这些创建调用指令和普通的消息调用唯一区别是：负载数据被执行，结果作为代码被存储，调用者在栈里收到了新合约的地址。

### 5.1.11 移除合约

从区块链中移除代码的唯一方法是合约在它的地址上执行了 selfdestruct 操作。这个账号下剩余的以太币会发送给指定的目标，存储和代码从栈中删除。
